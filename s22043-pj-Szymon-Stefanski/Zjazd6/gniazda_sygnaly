-------------------------------------------------------------
SYGNALY
-------------------------------------------------------------
OPIS:

Sygnaly sa informacja dla procesu, ze wystapilo jakies
zdarzenie - np sygnal konczacy uruchomiony proces.

By dowiedziec sie czegos wiecej nalezy wpisac komende:
man signal

SKLADNIA:

W bashu istnieje funkcja systemowa signal():

#include <signal.h>

typedef void(*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);

Po wywolaniu sygnalu "signum" w przypadku ustawienia
na SIG_IGN to sygnal zostaje zignorowany, w razie
utawienia na SIG_DFL podejmowana jest domyslna akcja
powiazana z sygnalem.

Jesli jako obsluga zostala ustawiona funkcja sighandler
to obsluga sygnalu inicjowana jest na SIG_DFL albo
odbywa sie zaleznie od ustawienia SIG_IGN a nastepnie
wywolywana jest funkcja sighandler z argumentem signum.

PODSUMOWANIE:
Pan Tomasz na zajeciach wyjasnil to w bardziej zrozumialy
sposob podajac przyklad z lekarzem z SORu - np. gdy opatruje
ludzi na SORze, ale nagle przybiega ktos i wola go aby
szybko stawil sie na sali operacyjnej do innego pacjenta
dlatego musi jak najszybciej zakonczyc/zignorowac obecne
obowiazki i zajac sie czyms innym.



-------------------------------------------------------------
GNIAZDA
-------------------------------------------------------------
OPIS:

Gniazda to nazwa okreslajaca dwukierunkowy punkt komunikacji
sieciowej, pozwalaja na wysylanie oraz odbieranie
danych - przykladem tego typu dzialania jest komunikacja
pomiedzy serwerem a klientem.

Nawiazanie takiej komunikacji wymaga, aby jeden z tych
procesow tj. serwer albo klient czekal na zgloszenie,
przy zgloszeniu i odebraniu go np. gdy serwer otrzyma
zgloszenie od klienta nastepuje polaczenie.

W przypadku, gdy zostanie nawiazane polaczenie i mamy do
czynienia z komunikacja miedzy serwerem a klientem:

a) Serwer przetwarza zgloszenie od klienta oraz ewentualnie
na nie odpowiada, po czym przechodzi w tryb dalszego
oczekiwania na nowe zgloszenia

b) Serwer przetwarza rozne zgloszenia od roznych klientow
przy uzyciu procesow potomnych itp. w tym samym czasie
dalej czeka na nowe zgloszenia

Klient nawiazujac polaczenie z konkretnym serwerem musi
posiadac informacje o jego adresie IP, oraz porcie na jakim
serwer "nasluchuje".



-------------------------------------------------------------
ZADANIE - SERWER i KLIENT
-------------------------------------------------------------
#########################################################
#			SYGNAL				#
#########################################################

SignalHandler:

#include<stdio.h>
#include<unistd.h>
#include<signal.h>

void registerHandler(int);
void signalHandler(int);

int main(){

    int x=1;

    while(x !=0){
        printf("Type 0 to finish.");
        fflush(stdout);
        scanf("%d", &x);
    }
    return 0;
}

void signalHandler(int s){
    printf("ERROR. s= %d", s);
}


void registerHandler(int s){
    sigset_t iset;
    struct sigaction act;

    sigemptyset(&iset);

    act.sa_handler = &signalHandler;
    act.sa_mask = iset;
    act.sa_flags = 0;
    sigaction(SIGINT, &act, NULL);
}

#########################################################
#			SERWER				#
#########################################################

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

void error(char *msg){
        perror(msg);
        exit(1);
}

int main(int argc, char *argv[]){

        int sockfd, newsockfd, portno, clilen;
        char buffer[256];
        struct sockaddr_in serv_addr, cli_addr;
        int n;
        if (argc<2){
                fprintf(stderr,"Error no port\n");
                exit(1);
        }
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if(sockfd<0){
                error("error opening sokcet");
        }
        bzero((char *) &serv_addr, sizeof(serv_addr));
        portno = atoi(argv[1]);
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = INADDR_ANY;
        serv_addr.sin_port = htons(portno);
        if(bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr))<0){  
                error("ERROR on binding");
        }       
        listen(sockfd,5);
        clilen = sizeof(cli_addr);
        newsockfd = accept(sockfd,(struct sockaddr *)  &cli_addr, &clilen);
        if(newsockfd<0){
                     error("ERROR on accept");
        }
         bzero(buffer,256);
         n = read (newsockfd,buffer,255);
         if (n< 0 ){
                  error("ERROR reading from socket");
         }
         printf("Here is the message %s\n",buffer);
          n = write(newsockfd,"i got your message ",18);
           if (n< 0 ){
                  error("ERROR writning to socket ");
         }


#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

void error(char *msg){
        perror(msg);
        exit(1);
}

int main(int argc, char *argv[]){

        int sockfd, newsockfd, portno, clilen;
        char buffer[256];
        struct sockaddr_in serv_addr, cli_addr;
        int n;
        if (argc<2){
                fprintf(stderr,"Error no port\n");
                exit(1);
        }
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if(sockfd<0){
                error("error opening sokcet");
        }
        bzero((char *) &serv_addr, sizeof(serv_addr));
        portno = atoi(argv[1]);  /* Numer portu*/
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = INADDR_ANY;
        serv_addr.sin_port = htons(portno);
        if(bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr))<0){  
                error("ERROR on binding");
        }       
        listen(sockfd,5);
        clilen = sizeof(cli_addr);
        newsockfd = accept(sockfd,(struct sockaddr *)  &cli_addr, &clilen);
        if(newsockfd<0){
                     error("ERROR on accept");
        }
         bzero(buffer,256);
         n = read (newsockfd,buffer,255);
         if (n< 0 ){
                  error("ERROR reading from socket");
         }
         printf("Here is the message %s\n",buffer);
          n = write(newsockfd,"i got your message ",18);
           if (n< 0 ){
                  error("ERROR writning to socket ");
                  }
                                
        return 0;

}


#########################################################
#			KLIENT				#
#########################################################

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>


void error(char *msg){
        perror(msg);
        exit(1);
}

int main(int argc, char *argv[]){

       int sockfd, portno,n;
         struct hostent *server;
       char buffer[256];
        struct sockaddr_in serv_addr, cli_addr;
        
        if (argc<3){
                fprintf(stderr,"Usage %s hostname port\n",argv[0]);
                exit(0);
        }
         portno = atoi(argv[2]);
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if(sockfd<0){
                error("error opening sokcet");
                
        }
        server == gethostbyname(argv[1]);
        if(server==NULL){
                fprintf(stderr,"error no such Host\n");
                exit(0);
        }

        bzero((char *) &serv_addr, sizeof(serv_addr));
                serv_addr.sin_family = AF_INET;
         bcopy((char *)server->h_addr,
        (char*)&serv_addr.sin_addr.s_addr,
        server->h_length);      
                
        serv_addr.sin_port = htons(portno);
        if(connect(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr))<0){
                error("ERROR conntecting");                      
        }
   printf("please enter the message"); 
        bzero(buffer,256); 
        fgets(buffer,255,stdin);
          n = write(sockfd,buffer,strlen(buffer));
            if (n< 0 ){
                  error("ERROR writning to socket ");
         }

            bzero(buffer,256);
              n = read (sockfd,buffer,255);
        if (n< 0 ){
                  error("ERROR reading from socket");
         }
         printf("%s\n",buffer);

 return 0;           
}

-------------------------------------------------------------
PRZYDATNE LINKI
-------------------------------------------------------------

Jako, ze jest to jeden z ciezszych tematow warto zapoznac
sie z ponizszymi linkami:

https://web.archive.org/web/20201107133926/https://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html

http://users.pja.edu.pl/~jms/qnx/help/tcpip_4.25_en/prog_guide/sock_advanced_tut.html

https://www.codeproject.com/Articles/586000/Networking-and-Socket-Programming-Tutorial-in-C
